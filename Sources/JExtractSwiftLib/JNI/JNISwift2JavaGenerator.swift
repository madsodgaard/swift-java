//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import JavaTypes

struct JNISwift2JavaGenerator: Swift2JavaGenerator {
  let analysis: AnalysisResult
  let swiftModuleName: String
  let javaPackage: String
  let logger: Logger
  let swiftOutputDirectory: String
  let javaOutputDirectory: String

  var javaPackagePath: String {
    javaPackage.replacingOccurrences(of: ".", with: "/")
  }

  init(
    translator: Swift2JavaTranslator,
    javaPackage: String,
    swiftOutputDirectory: String,
    javaOutputDirectory: String
  ) {
    self.logger = Logger(label: "jni-generator", logLevel: translator.log.logLevel)
    self.analysis = translator.result
    self.swiftModuleName = translator.swiftModuleName
    self.javaPackage = javaPackage
    self.swiftOutputDirectory = swiftOutputDirectory
    self.javaOutputDirectory = javaOutputDirectory
  }

  func generate() throws {
    try writeExportedJavaSources()
  }
}

extension JNISwift2JavaGenerator {
  func writeExportedJavaSources() throws {
    var printer = CodePrinter()

    let filename = "\(self.swiftModuleName).java"
    logger.trace("Printing module class: \(filename)")
    printModule(&printer)

    if let outputFile = try printer.writeContents(
      outputDirectory: javaOutputDirectory,
      javaPackagePath: javaPackagePath,
      filename: filename
    ) {
      logger.info("[swift-java] Generated: \(self.swiftModuleName).java (at \(outputFile))")
    }
  }
}

extension JNISwift2JavaGenerator {
  private func printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)

    printModuleClass(&printer) { printer in
      for decl in analysis.importedGlobalFuncs {
        self.logger.trace("Print global function: \(decl)")
        printFunctionBinding(&printer, decl)
      }
    }
  }

  private func printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-swift
      // Swift module: \(swiftModuleName)

      """
    )
  }

  private func printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  private func printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(swiftModuleName)") { printer in
      body(&printer)
    }
  }

  private func printFunctionBinding(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    let returnType = decl.functionSignature.result.type.javaType
    let params = decl.functionSignature.parameters.map {
      "\($0.type.javaType) \($0.parameterName!)"
    }

    printer.print("public static native \(returnType) \(decl.name)(\(params.joined(separator: ", ")));")
  }
}

extension SwiftType {
  var javaType: JavaType {
    switch self {
    case .nominal(let nominalType):
      if let knownType = nominalType.nominalTypeDecl.knownStandardLibraryType {
        guard let javaType = knownType.javaType else {
          fatalError("unsupported known type: \(knownType)")
        }
        return javaType
      }

      fatalError("unsupported nominal type: \(nominalType)")

    case .tuple([]):
      return .void

    case .metatype, .optional, .tuple, .function:
      fatalError("unsupported")
    }
  }
}

extension KnownStandardLibraryType {
  var javaType: JavaType? {
    switch self {
    case .bool: .boolean
    case .int, .uint: .long // TODO: Handle 32-bit or 64-bit
    case .int8, .uint8: .byte
    case .uint16: .char
    case .int16: .short
    case .int32, .uint32: .int
    case .int64, .uint64: .long
    case .float: .float
    case .double: .double
    case .void: .void
    case .unsafeRawPointer, .unsafeMutableRawPointer, .unsafePointer, .unsafeMutablePointer, .unsafeBufferPointer, .unsafeMutableBufferPointer, .string: nil
    }
  }
}
